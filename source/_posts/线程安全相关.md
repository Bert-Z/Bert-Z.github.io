---
title: 线程安全相关
date: 2020-07-27 01:12:22
tags: Thread-safe
categories:
cover: https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRGgwOsx3UW-BNAUo7p770__27WOKfa-OUXnQ&usqp=CAU
---
<meta name="referrer" content="no-referrer" />

## 定义

- 多个线程同时访问时，其表现出争取的行为。
- 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织。
- 调用端代码无须额外的同步或其他协调动作。



## 可重入 vs 不可重入

可重入函数也可以这样理解，重入即表示重复进入，首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这样的函数就是purecode（纯代码）可重入，可以允许有多个该函数的副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。如果确实需要访问全局变量（包括static），一定要注意实施互斥手段。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价。

而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。



## 对象创建很简单

对象构造要做到线程安全，唯一的要求是在构造期间不要泄露this指针，即

- 不要在构造函数中注册任何回调；
- 也不要在构造函数中把this传给跨线程的对象；
- 即便在构造函数的最后一行也不行。



## 销毁太难

- mutex 作为成员函数是不能保护析构的。



## 对象池来调度也可能存在问题

- 对象池的线程安全，如何安全地、完整地把对象放回池子里，防止出现“部分放回”的竞态？
- 全局共享数据引发的lock contention，这个集中化的对象池会不会把多线程并发的操作串行化？
- 如果共享对象的类型不止一种，那么重复实现对象池还是使用类模板？
- 会不会造成内存泄漏与分片？因为对象池内存只增不减，而且多个对象池不能共享内存。

Observer的实现也非常麻烦。不知道对象死了没。



## 万能的解决方案

引入一层间接性，用对象来管理共享资源，亦即body/handle惯用技法。--->智能指针



## C++可能出现的内存问题及解决方案

- **缓冲区溢出**：用std::vector<char>/std::string或自己编写的buffer class来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是裸指针来修改缓冲区。
- **空悬指针**：用智能指针。
- **重复释放**：同上。
- **内存泄漏**：同上。
- **不配对的new[]/delete**：将new[]统一换成vector。
- **内存碎片问题**：不好解决。



## 再论shared_ptr的线程安全

shared_ptr的线程安全级别和内建类型、标准库容器、std::string一样，即：

- 一个shared_ptr对象实体可被多线程同时读取；
- 两个shared_ptr对象实体可被两个线程同时写入，“析构”算写操作；
- 如果要从多个线程读写同一个shared_ptr对象，那么需要加锁。


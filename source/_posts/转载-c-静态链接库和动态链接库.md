---
title: '[转载]c++ 静态链接库和动态链接库'
date: 2020-07-28 08:14:51
tags: Cpp
categories:
cover: https://pic4.zhimg.com/50/72b693726d70eea37aacbb93d8d40a43_hd.jpg?source=1940ef5c
---
<meta name="referrer" content="no-referrer" />



什么是库？

库是写好的现有的，成熟的，可以复用的代码。**现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常**。

本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。  windows上对应的是.lib .dll linux上对应的是.a .so





在这里先介绍下Linux下的gcc编译的几个选项

```shell
g++ -c hellospeak.cpp
```

会将hellospeak.cpp  选项 -c 用来告诉编译器编译源代码但不要执行链接，输出结果为对象文件。文件默认名与源码文件名相同，只是将其后缀变为 .o。例如，上面的命令将编译源码文件hellospeak.cpp 并生成对象文件 hellospeak.o；

下面这条命令将上述两个源码文件编译链接成一个单一的可执行程序： 

```shell
g++ hellospeak.cpp speak.cpp -o hellospeak
```

如果没有-o和后面的参数，编译器采用默认的 a.out
本例中就会生成hellospeak 这样的可执行程序



所谓静态、动态是指链接。回顾一下，将一个程序编译成可执行程序的步骤：

图：编译过程



![img](https://pic4.zhimg.com/50/72b693726d70eea37aacbb93d8d40a43_hd.jpg?source=1940ef5c)



静态库

之所以成为【静态库】，**是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。**



试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，**那么静态库必定跟*.o*文件格式相似**。其实一个静态库可以简单看成是一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结：



**l  静态库对函数库的链接是放在编译时期完成的。**

**l  程序在运行时与函数库再无瓜葛，移植方便。**

**l  浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。**



Linux下创建与使用静态库

Linux静态库命名规则

Linux静态库命名规范，必须是"lib[your_library_name].a"：lib为前缀，中间是静态库名，扩展名为.a。

创建静态库（.a）

通过上面的流程可以知道，Linux创建静态库过程如下：

l  首先，将代码文件编译成目标文件.o（StaticMath.o）

**g++ -c StaticMath.cpp**

注意带参数-c，否则直接编译为可执行文件

l  然后，通过ar工具将目标文件打包成.a静态库文件

**ar -crv libstaticmath.a StaticMath.o**

生成静态库**libstaticmath.a**。



![img](https://pic4.zhimg.com/80/f798fdffbee291d83ad26a08ed1b28ac_720w.jpg?source=1940ef5c)









-------------------------------分割线------------------------



动态库

通过上面的介绍发现静态库，容易使用和理解，也达到了代码复用的目的，那为什么还需要动态库呢？

为什么还需要动态库？

为什么需要动态库，其实也是静态库的特点导致。

l  空间浪费是静态库的一个问题。



![img](https://pic2.zhimg.com/50/6aac2e2dc8faa8d1008f5320a7a83f5d_hd.jpg?source=1940ef5c)

另一个问题是静态库对程序的更新、部署和发布页会带来麻烦。如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载，**全量更新**）。



动态库在程序编译时并不会被连接到目标代码中，而是在程序运行时才被载入。**不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例**，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，**增量更新**。



![img](https://picb.zhimg.com/80/73f097608fecb37ffc4128273341376e_720w.jpg?source=1940ef5c)

动态库特点总结：

l  动态库把对一些库函数的链接载入推迟到程序运行的时期。

l  可以实现进程之间的资源共享。（因此动态库也称为共享库）

l  将一些程序升级变得简单。

l  甚至可以真正做到链接载入完全由程序员在程序代码中控制（**显示调用**）。

Window与Linux执行文件格式不同，在创建动态库的时候有一些差异。

l  在Windows系统下的执行文件格式是PE格式，动态库需要一个**DllMain**函数做出初始化的入口，通常在导出函数的声明时需要有_declspec(dllexport)**关键字**。

l  Linux下gcc编译的执行文件默认是ELF格式，**不需要初始化入口，亦不需要函数做特别的声明，**编写比较方便。

与创建静态库不同的是，不需要打包工具（ar、lib.exe），直接使用编译器即可创建动态库。
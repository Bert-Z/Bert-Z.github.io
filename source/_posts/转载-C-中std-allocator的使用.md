---
title: '[转载]C++中std::allocator的使用'
date: 2020-08-24 06:49:05
tags: Cpp
categories:
cover: https://img-blog.csdn.net/20171231221141460
---
<meta name="referrer" content="no-referrer" />

标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。

​    new有一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造组合在了一起。类似的，delete将对象析构和内存释放组合在了一起。我们分配单个对象时，通常希望将内存分配和对象初始化组合在一起。因为在这种情况下，我们几乎肯定知道对象应有什么值。当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象的创建操作(同时付出一定开销)。**一般情况下，将内存分配和对象构造组合在一起可能会导致不必要的浪费**。

​    **标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来**。**它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的**。类似vector，allocator是一个模板。为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置。allocator支持的操作，如下：

![img](https://img-blog.csdn.net/20171231221141460)

​    allocatro分配的内存是未构造的(unconstructed)。我们按需要在此内存中构造对象。在新标准库中，construct成员函数接受一个指针和零个或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象。类似make_shared的参数，这些额外参数必须是与构造的对象的类型相匹配的合法的初始化器。

​    在早期版本的标准库中，construct只接受两个参数：指向创建对象位置的指针和一个元素类型的值。因此，我们只能将一个元素拷贝到未构造空间中，而不能用元素类型的任何其它构造函数来构造一个元素。**还未构造对象的情况下就使用原始内存是错误的**。为了使用allocator返回的内存，我们必须用construct构造对象。使用未构造的内存，其行为是未定义的。

​    **当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们**。函数destroy接受一个指针，对执行的对象执行析构函数。**我们只能对真正构造了的元素进行destroy操作**。一旦元素被销毁后，就可以重新使用这部分内存来保存其它string，也可以将其归还给系统。释放内存通过调用deallocate来完成。我们传递给deallocate的指针不能为空，它必须指向由allocate分配的内存。而且，传递给deallocate的大小参数必须与调用allocate分配内存时提供的大小参数具有一样的值。

​    标准库还为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。它们都定义在头文件memory中，如下：

![img](https://img-blog.csdn.net/20171231221210812)

​    在C++中，内存是通过new表达式分配，通过delete表达式释放的。标准库还定义了一个allocator类来分配动态内存块。分配动态内存的程序应负责释放它所分配的内存。内存的正确释放是非常容易出错的地方：要么内存永远不会被释放，要么在仍有指针引用它时就被释放了。新的标准库定义了智能指针类型------shared_ptr、unique_ptr和weak_ptr，可令动态内存管理更为安全。对于一块内存，当没有任何用户使用它时，智能指针会自动释放它。现代C++程序应尽可能使用智能指针。

​    std::allocator是标准库容器的默认内存分配器。你可以替换自己的分配器，这允许你控制标准容器分配内存的方式。
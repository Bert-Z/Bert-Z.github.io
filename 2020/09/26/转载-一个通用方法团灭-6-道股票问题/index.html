<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>[转载]一个通用方法团灭 6 道股票问题 | Bert Zhang</title><meta name="description" content="一个通用方法团灭 6 道股票问题本文思路参考自英文版 LeetCode 题解： https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock-with-transaction-fee&#x2F;discuss&#x2F;108870&#x2F;Most-consistent-ways-of-dealing-with-the-series-of-stock-pro"><meta name="keywords" content="Algorithm"><meta name="author" content="Bert Zhang,wanqiangzhang@sjtu.edu.cn"><meta name="copyright" content="Bert Zhang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="[转载]一个通用方法团灭 6 道股票问题"><meta name="twitter:description" content="一个通用方法团灭 6 道股票问题本文思路参考自英文版 LeetCode 题解： https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock-with-transaction-fee&#x2F;discuss&#x2F;108870&#x2F;Most-consistent-ways-of-dealing-with-the-series-of-stock-pro"><meta name="twitter:image" content="https://pic.leetcode-cn.com/1598149473-kfUWNl-1.png"><meta property="og:type" content="article"><meta property="og:title" content="[转载]一个通用方法团灭 6 道股票问题"><meta property="og:url" content="https://bert-z.github.io/2020/09/26/%E8%BD%AC%E8%BD%BD-%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95%E5%9B%A2%E7%81%AD-6-%E9%81%93%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"><meta property="og:site_name" content="Bert Zhang"><meta property="og:description" content="一个通用方法团灭 6 道股票问题本文思路参考自英文版 LeetCode 题解： https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock-with-transaction-fee&#x2F;discuss&#x2F;108870&#x2F;Most-consistent-ways-of-dealing-with-the-series-of-stock-pro"><meta property="og:image" content="https://pic.leetcode-cn.com/1598149473-kfUWNl-1.png"><meta property="article:published_time" content="2020-09-26T14:26:09.000Z"><meta property="article:modified_time" content="2020-09-26T14:26:49.841Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://bert-z.github.io/2020/09/26/%E8%BD%AC%E8%BD%BD-%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95%E5%9B%A2%E7%81%AD-6-%E9%81%93%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"><link rel="prev" title="[转载]Bloom Filter概念和原理" href="https://bert-z.github.io/2020/10/21/%E8%BD%AC%E8%BD%BD-Bloom-Filter%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/"><link rel="next" title="[转载]欧拉路径和Hierholzer算法" href="https://bert-z.github.io/2020/09/24/%E8%BD%AC%E8%BD%BD-%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E5%92%8CHierholzer%E7%AE%97%E6%B3%95/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://avatars0.githubusercontent.com/u/33542391?s=460&amp;u=db2ad59370788a7d3c85017aec44089206bd9494&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">78</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">30</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一个通用方法团灭-6-道股票问题"><span class="toc-number">1.</span> <span class="toc-text">一个通用方法团灭 6 道股票问题</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://pic.leetcode-cn.com/1598149473-kfUWNl-1.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bert Zhang</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">[转载]一个通用方法团灭 6 道股票问题</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-09-26 14:26:09"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-09-26</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-09-26 14:26:49"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-09-26</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><meta name="referrer" content="no-referrer" />

<h1 id="一个通用方法团灭-6-道股票问题"><a href="#一个通用方法团灭-6-道股票问题" class="headerlink" title="一个通用方法团灭 6 道股票问题"></a>一个通用方法团灭 6 道股票问题</h1><p>本文思路参考自英文版 LeetCode 题解：</p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems</a></p>
<p>读完本文，你可以去力扣拿下如下题目：</p>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/" target="_blank" rel="noopener">买卖股票的最佳时机</a></p>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机 II</a></p>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">买卖股票的最佳时机 III</a></p>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">买卖股票的最佳时机 IV</a></p>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">最佳买卖股票时机含冷冻期</a></p>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">买卖股票的最佳时机含手续费</a></p>
<p><strong>———–</strong></p>
<p>很多读者抱怨 LeetCode 的股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？<strong>所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变</strong>。</p>
<p>这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。</p>
<p>这 6 道题目是有共性的，我就抽出来第 4 道题目，因为这道题是一个最泛化的形式，其他的问题都是这个形式的简化，看下题目：</p>
<p><img src="https://pic.leetcode-cn.com/1598149473-FWHCcw-title.png" alt="img"></p>
<p>第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。</p>
<p>如果你还不熟悉题目，可以去 LeetCode 查看这些题目的内容，本文为了节省篇幅，就不列举这些题目的具体内容了。下面言归正传，开始解题。</p>
<p><strong>一、穷举框架</strong></p>
<p>首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。</p>
<p>递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。</p>
<p>而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 状态1 in 状态1的所有取值：</span><br><span class="line">    for 状态2 in 状态2的所有取值：</span><br><span class="line">        for ...</span><br><span class="line">            dp[状态1][状态2][...] &#x3D; 择优(选择1，选择2...)</span><br></pre></td></tr></table></figure>

<p>比如说这个问题，<strong>每天都有三种「选择」</strong>：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。</p>
<p>很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。<strong>这个问题的「状态」有三个</strong>，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][0 or 1]</span><br><span class="line">0 &lt;&#x3D; i &lt;&#x3D; n-1, 1 &lt;&#x3D; k &lt;&#x3D; K</span><br><span class="line">n 为天数，大 K 为最多交易数</span><br><span class="line">此问题共 n × K × 2 种状态，全部穷举就能搞定。</span><br><span class="line"></span><br><span class="line">for 0 &lt;&#x3D; i &lt; n:</span><br><span class="line">    for 1 &lt;&#x3D; k &lt;&#x3D; K:</span><br><span class="line">        for s in &#123;0, 1&#125;:</span><br><span class="line">            dp[i][k][s] &#x3D; max(buy, sell, rest)</span><br></pre></td></tr></table></figure>

<p>而且我们可以用自然语言描述出每一个状态的含义，比如说 <code>dp[3][2][1]</code> 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 <code>dp[2][3][0]</code> 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？</p>
<p>我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。</p>
<p>记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。</p>
<p><strong>二、状态转移框架</strong></p>
<p>现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。</p>
<p><img src="https://pic.leetcode-cn.com/1598149473-kfUWNl-1.png" alt="img"></p>
<p>通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][0] &#x3D; max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span><br><span class="line">              max(   选择 rest  ,             选择 sell      )</span><br><span class="line"></span><br><span class="line">解释：今天我没有持有股票，有两种可能：</span><br><span class="line">要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；</span><br><span class="line">要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</span><br><span class="line"></span><br><span class="line">dp[i][k][1] &#x3D; max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span><br><span class="line">              max(   选择 rest  ,           选择 buy         )</span><br><span class="line"></span><br><span class="line">解释：今天我持有着股票，有两种可能：</span><br><span class="line">要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；</span><br><span class="line">要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</span><br></pre></td></tr></table></figure>

<p>这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。</p>
<p>现在，我们已经完成了动态规划中最困难的一步：状态转移方程。<strong>如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。</strong>不过还差最后一点点，就是定义 base case，即最简单的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dp[-1][k][0] &#x3D; 0</span><br><span class="line">解释：因为 i 是从 0 开始的，所以 i &#x3D; -1 意味着还没有开始，这时候的利润当然是 0 。</span><br><span class="line">dp[-1][k][1] &#x3D; -infinity</span><br><span class="line">解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</span><br><span class="line">dp[i][0][0] &#x3D; 0</span><br><span class="line">解释：因为 k 是从 1 开始的，所以 k &#x3D; 0 意味着根本不允许交易，这时候利润当然是 0 。</span><br><span class="line">dp[i][0][1] &#x3D; -infinity</span><br><span class="line">解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。</span><br></pre></td></tr></table></figure>

<p>把上面的状态转移方程总结一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">base case：</span><br><span class="line">dp[-1][k][0] &#x3D; dp[i][0][0] &#x3D; 0</span><br><span class="line">dp[-1][k][1] &#x3D; dp[i][0][1] &#x3D; -infinity</span><br><span class="line"></span><br><span class="line">状态转移方程：</span><br><span class="line">dp[i][k][0] &#x3D; max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span><br><span class="line">dp[i][k][1] &#x3D; max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span><br></pre></td></tr></table></figure>

<p>读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。</p>
<p><strong>三、秒杀题目</strong></p>
<p><strong>第一题，k = 1</strong></p>
<p>直接套状态转移方程，根据 base case，可以做一些化简：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[i][1][0] &#x3D; max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])</span><br><span class="line">dp[i][1][1] &#x3D; max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) </span><br><span class="line">            &#x3D; max(dp[i-1][1][1], -prices[i])</span><br><span class="line">解释：k &#x3D; 0 的 base case，所以 dp[i-1][0][0] &#x3D; 0。</span><br><span class="line"></span><br><span class="line">现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。</span><br><span class="line">可以进行进一步化简去掉所有 k：</span><br><span class="line">dp[i][0] &#x3D; max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br><span class="line">dp[i][1] &#x3D; max(dp[i-1][1], -prices[i])</span><br></pre></td></tr></table></figure>

<p>直接写出代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int n &#x3D; prices.length;</span><br><span class="line">int[][] dp &#x3D; new int[n][2];</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i][0] &#x3D; Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);</span><br><span class="line">    dp[i][1] &#x3D; Math.max(dp[i-1][1], -prices[i]);</span><br><span class="line">&#125;</span><br><span class="line">return dp[n - 1][0];</span><br></pre></td></tr></table></figure>

<p>显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    if (i - 1 &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        dp[i][0] &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 解释：</span><br><span class="line">        &#x2F;&#x2F;   dp[i][0] </span><br><span class="line">        &#x2F;&#x2F; &#x3D; max(dp[-1][0], dp[-1][1] + prices[i])</span><br><span class="line">        &#x2F;&#x2F; &#x3D; max(0, -infinity + prices[i]) &#x3D; 0</span><br><span class="line">        dp[i][1] &#x3D; -prices[i];</span><br><span class="line">        &#x2F;&#x2F;解释：</span><br><span class="line">        &#x2F;&#x2F;   dp[i][1] </span><br><span class="line">        &#x2F;&#x2F; &#x3D; max(dp[-1][1], dp[-1][0] - prices[i])</span><br><span class="line">        &#x2F;&#x2F; &#x3D; max(-infinity, 0 - prices[i]) </span><br><span class="line">        &#x2F;&#x2F; &#x3D; -prices[i]</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][0] &#x3D; Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);</span><br><span class="line">    dp[i][1] &#x3D; Math.max(dp[i-1][1], -prices[i]);</span><br><span class="line">&#125;</span><br><span class="line">return dp[n - 1][0];</span><br></pre></td></tr></table></figure>

<p>第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; k &#x3D;&#x3D; 1</span><br><span class="line">int maxProfit_k_1(int[] prices) &#123;</span><br><span class="line">    int n &#x3D; prices.length;</span><br><span class="line">    &#x2F;&#x2F; base case: dp[-1][0] &#x3D; 0, dp[-1][1] &#x3D; -infinity</span><br><span class="line">    int dp_i_0 &#x3D; 0, dp_i_1 &#x3D; Integer.MIN_VALUE;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; dp[i][0] &#x3D; max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br><span class="line">        dp_i_0 &#x3D; Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        &#x2F;&#x2F; dp[i][1] &#x3D; max(dp[i-1][1], -prices[i])</span><br><span class="line">        dp_i_1 &#x3D; Math.max(dp_i_1, -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。</p>
<p><strong>第二题，k = +infinity</strong></p>
<p>如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][0] &#x3D; max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span><br><span class="line">dp[i][k][1] &#x3D; max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span><br><span class="line">            &#x3D; max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])</span><br><span class="line"></span><br><span class="line">我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：</span><br><span class="line">dp[i][0] &#x3D; max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br><span class="line">dp[i][1] &#x3D; max(dp[i-1][1], dp[i-1][0] - prices[i])</span><br></pre></td></tr></table></figure>

<p>直接翻译成代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit_k_inf(int[] prices) &#123;</span><br><span class="line">    int n &#x3D; prices.length;</span><br><span class="line">    int dp_i_0 &#x3D; 0, dp_i_1 &#x3D; Integer.MIN_VALUE;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        int temp &#x3D; dp_i_0;</span><br><span class="line">        dp_i_0 &#x3D; Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 &#x3D; Math.max(dp_i_1, temp - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三题，k = +infinity with cooldown</strong></p>
<p>每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] &#x3D; max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br><span class="line">dp[i][1] &#x3D; max(dp[i-1][1], dp[i-2][0] - prices[i])</span><br><span class="line">解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。</span><br></pre></td></tr></table></figure>

<p>翻译成代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit_with_cool(int[] prices) &#123;</span><br><span class="line">    int n &#x3D; prices.length;</span><br><span class="line">    int dp_i_0 &#x3D; 0, dp_i_1 &#x3D; Integer.MIN_VALUE;</span><br><span class="line">    int dp_pre_0 &#x3D; 0; &#x2F;&#x2F; 代表 dp[i-2][0]</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        int temp &#x3D; dp_i_0;</span><br><span class="line">        dp_i_0 &#x3D; Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 &#x3D; Math.max(dp_i_1, dp_pre_0 - prices[i]);</span><br><span class="line">        dp_pre_0 &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第四题，k = +infinity with fee</strong></p>
<p>每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] &#x3D; max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br><span class="line">dp[i][1] &#x3D; max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)</span><br><span class="line">解释：相当于买入股票的价格升高了。</span><br><span class="line">在第一个式子里减也是一样的，相当于卖出股票的价格减小了。</span><br></pre></td></tr></table></figure>

<p>直接翻译成代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit_with_fee(int[] prices, int fee) &#123;</span><br><span class="line">    int n &#x3D; prices.length;</span><br><span class="line">    int dp_i_0 &#x3D; 0, dp_i_1 &#x3D; Integer.MIN_VALUE;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        int temp &#x3D; dp_i_0;</span><br><span class="line">        dp_i_0 &#x3D; Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 &#x3D; Math.max(dp_i_1, temp - prices[i] - fee);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第五题，k = 2</strong></p>
<p>k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。</p>
<p>这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始的动态转移方程，没有可化简的地方</span><br><span class="line">dp[i][k][0] &#x3D; max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span><br><span class="line">dp[i][k][1] &#x3D; max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span><br></pre></td></tr></table></figure>

<p>按照之前的代码，我们可能想当然这样写代码（错误的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int k &#x3D; 2;</span><br><span class="line">int[][][] dp &#x3D; new int[n][k + 1][2];</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">    if (i - 1 &#x3D;&#x3D; -1) &#123; </span><br><span class="line">        &#x2F;&#x2F; base case </span><br><span class="line">        dp[i][0] &#x3D; 0;</span><br><span class="line">        dp[i][1] &#x3D; -prices[i];</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][k][0] &#x3D; Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);</span><br><span class="line">    dp[i][k][1] &#x3D; Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);</span><br><span class="line">&#125;</span><br><span class="line">return dp[n - 1][k][0];</span><br></pre></td></tr></table></figure>

<p>为什么错误？我这不是照着状态转移方程写的吗？</p>
<p>还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int max_k &#x3D; 2;</span><br><span class="line">int[][][] dp &#x3D; new int[n][max_k + 1][2];</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    for (int k &#x3D; max_k; k &gt;&#x3D; 1; k--) &#123;</span><br><span class="line">        if (i - 1 &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            &#x2F;&#x2F; base case </span><br><span class="line">            dp[i][0] &#x3D; 0;</span><br><span class="line">            dp[i][1] &#x3D; -prices[i];</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][k][0] &#x3D; max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);</span><br><span class="line">        dp[i][k][1] &#x3D; max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 穷举了 n × max_k × 2 个状态，正确。</span><br><span class="line">return dp[n - 1][max_k][0];</span><br></pre></td></tr></table></figure>

<p>如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。</p>
<p>这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况全部列举出来也可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dp[i][2][0] &#x3D; max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])</span><br><span class="line">dp[i][2][1] &#x3D; max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])</span><br><span class="line">dp[i][1][0] &#x3D; max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])</span><br><span class="line">dp[i][1][1] &#x3D; max(dp[i-1][1][1], -prices[i])</span><br><span class="line"></span><br><span class="line">int maxProfit_k_2(int[] prices) &#123;</span><br><span class="line">    int dp_i10 &#x3D; 0, dp_i11 &#x3D; Integer.MIN_VALUE;</span><br><span class="line">    int dp_i20 &#x3D; 0, dp_i21 &#x3D; Integer.MIN_VALUE;</span><br><span class="line">    for (int price : prices) &#123;</span><br><span class="line">        dp_i20 &#x3D; Math.max(dp_i20, dp_i21 + price);</span><br><span class="line">        dp_i21 &#x3D; Math.max(dp_i21, dp_i10 - price);</span><br><span class="line">        dp_i10 &#x3D; Math.max(dp_i10, dp_i11 + price);</span><br><span class="line">        dp_i11 &#x3D; Math.max(dp_i11, -price);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp_i20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会大惊失色，对你肃然起敬。</p>
<p><strong>第六题，k = any integer</strong></p>
<p>有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？</p>
<p>一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。</p>
<p>直接把之前的代码重用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit_k_any(int max_k, int[] prices) &#123;</span><br><span class="line">    int n &#x3D; prices.length;</span><br><span class="line">    if (max_k &gt; n &#x2F; 2) </span><br><span class="line">        return maxProfit_k_inf(prices);</span><br><span class="line"></span><br><span class="line">    int[][][] dp &#x3D; new int[n][max_k + 1][2];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) </span><br><span class="line">        for (int k &#x3D; max_k; k &gt;&#x3D; 1; k--) &#123;</span><br><span class="line">            if (i - 1 &#x3D;&#x3D; -1) &#123;</span><br><span class="line">                &#x2F;&#x2F; base case </span><br><span class="line">                dp[i][0] &#x3D; 0;</span><br><span class="line">                dp[i][1] &#x3D; -prices[i];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][k][0] &#x3D; max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);</span><br><span class="line">            dp[i][k][1] &#x3D; max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);     </span><br><span class="line">        &#125;</span><br><span class="line">    return dp[n - 1][max_k][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，6 道题目通过一个状态转移方程全部解决。</p>
<p><strong>四、最后总结</strong></p>
<p>本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。</p>
<p>关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？</p>
<p>具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:wanqiangzhang@sjtu.edu.cn">Bert Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://bert-z.github.io/2020/09/26/%E8%BD%AC%E8%BD%BD-%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95%E5%9B%A2%E7%81%AD-6-%E9%81%93%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/">https://bert-z.github.io/2020/09/26/%E8%BD%AC%E8%BD%BD-%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95%E5%9B%A2%E7%81%AD-6-%E9%81%93%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm</a></div><div class="post_share"><div class="social-share" data-image="https://68.media.tumblr.com/953cf79fb096626b9d7b931f1fe605b1/tumblr_inline_oh2b4bgQtZ1qcg73w_540.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/10/21/%E8%BD%AC%E8%BD%BD-Bloom-Filter%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/"><img class="prev_cover" src="https://p-blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf2.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">[转载]Bloom Filter概念和原理</div></div></a></div><div class="next-post pull_right"><a href="/2020/09/24/%E8%BD%AC%E8%BD%BD-%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E5%92%8CHierholzer%E7%AE%97%E6%B3%95/"><img class="next_cover" src="https://upload-images.jianshu.io/upload_images/7749027-8ea3598caabe688a.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/568/format/webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">[转载]欧拉路径和Hierholzer算法</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/05/13/BucketSort/" title="BucketSort"><img class="relatedPosts_cover" src="https://media.geeksforgeeks.org/wp-content/uploads/BucketSort.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-13</div><div class="relatedPosts_title">BucketSort</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/15/Catalan-Number/" title="Catalan Number"><img class="relatedPosts_cover" src="https://helloacm.com/wp-content/uploads/2019/12/catalan-numbers-applications.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-15</div><div class="relatedPosts_title">Catalan Number</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/13/Introsort/" title="Introsort"><img class="relatedPosts_cover" src="https://i.ytimg.com/vi/67ta5WTjjUo/maxresdefault.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-13</div><div class="relatedPosts_title">Introsort</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/13/Ring-Buffer/" title="Ring Buffer"><img class="relatedPosts_cover" src="https://w.wallhaven.cc/full/vg/wallhaven-vglkw3.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-13</div><div class="relatedPosts_title">Ring Buffer</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/25/取球游戏/" title="取球游戏"><img class="relatedPosts_cover" src="/images/取球问题/IMG_20200525_223310.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-25</div><div class="relatedPosts_title">取球游戏</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/06/转载-滑动窗口技巧/" title="[转载]滑动窗口技巧"><img class="relatedPosts_cover" src="https://github.com/labuladong/fucking-algorithm/raw/master/pictures/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-06</div><div class="relatedPosts_title">[转载]滑动窗口技巧</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Bert Zhang</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>